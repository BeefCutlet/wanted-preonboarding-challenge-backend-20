## 원티드 프리온보딩 챌린지 백엔드 20 사전과제

### 기술스택
Java 17, Spring Boot, JPA, H2 DB, JUnit5


### ERD
![PreOnBoardingERD](https://github.com/BeefCutlet/wanted-preonboarding-challenge-backend-20/assets/77325024/c528f552-ea56-4ae8-94ab-b9c965730942)



### API

| Domain | HTTP Method | URL                        | Detail                           |
|:------:|:-----------:|:---------------------------|----------------------------------|
|  Auth  |    POST     | /auth/login                | 로그인                              |
| Member |    POST     | /members/sign-up           | 회원가입                             |
|  Item  |    POST     | /items                     | 제품 등록                            |
|        |     GET     | /items/list                | 제품 목록 조회                         |
|        |     GET     | /items/{itemId}            | 제품 단건 조회                         |
| Order  |    POST     | /orders                    | 주문 등록                            |
|        |     PUT     | /orders/approval           | 주문 상태 변경 - 판매승인                  |
|        |     PUT     | /orders/completion         | 주문 상태 변경 - 구매확정                  |
|        |     GET     | /orders/history/{itemId}   | 제품에 대한 판매자와의 거래 내역 조회            |
|        |     GET     | /orders/completion         | 구매자가 구매 확정한 주문 내역 조회             |
|        |     GET     | /orders/approval           | 구매자가 구매 요청한 주문 중 판매 승인된 주문 내역 조회 |
|        |     GET     | /orders/reservation        | 구매자가 구매 예약한 주문 조회                |
|        |     GET     | /orders/seller/reservation | 판매자가 구매 요청 받은 주문 목록 조회           |

### API 상세
https://hsa-1.gitbook.io/wantedpobackend/


### 요구사항 구현 상세
- 회원, 제품, 주문 도메인으로 구분하여 구현하였습니다. 
- 회원이 로그인할 때에는 톰캣에서 제공하는 세션 저장소에 인증 정보를 저장하였습니다. 
- 회원이 제품을 구매하는 과정을 다음과 같이 이해하여 구현하였습니다.
  1. 구매하기 버튼을 클릭한다. 이 때, 주문 정보가 DB에 저장되며 주문 상태는 구매 예약 상태(RESERVED)로 저장됩니다.
  2. 판매자는 본인이 등록한 제품에 대한 구매 요청(구매 예약 상태)을 조회할 수 있으며, 판매 승인을 할 수 있습니다. 판매승인을 하면 주문 상태가 판매 승인 상태(APPROVED)로 변경됩니다.
  3. 구매자는 본인이 구매 예약한 제품 중 판매 승인이 이루어진 주문 내역을 조회할 수 있으며, 구매 확정을 할 수 있습니다. 구매 확정을 하면 주문 상태가 구매 확정 상태(COMPLETE)로 변경됩니다.
- 구매 확정 상태가 되면 구매가 완료된 것으로 간주합니다.
- 구매자가 조회할 수 있는 주문 내역은 다음과 같습니다.
  1. 본인이 구매 요청한 제품 중 구매 예약(RESERVED) 상태의 주문 내역
  2. 본인이 구매 요청한 제품 중 판매 승인(APPROVED) 상태의 주문 내역
  3. 주문 상세 정보 조회 시, 해당 제품에 대한 판매자와의 거래 내역 (현재 주문 상태 포함)
- 판매자가 조회할 수 있는 주문 내역은 다음과 같습니다.
  1. 본인이 등록한 제품 중 구매 요청을 받은 제품 목록 (RESERVED 상태만)
  2. 주문 상세 정보 조회 시, 해당 제품에 대한 모든 구매자와의 거래 내역 (현재 주문 상태 포함)

> 판매자와 구매자는 제품의 상세정보를 조회하면 당사자간의 거래내역을 확인할 수 있습니다.\
> \
> 라는 요구사항에 대하여 구매자의 경우, 해당 제품에 대한 판매자와의 거래 내역을 조회한다고 이해하였습니다.\
> 그런데 판매자의 경우, 하나의 구매자와의 거래 내역을 특정하여 조회할 수 없기 때문에 "당사자 간의 거래 내역"을 "해당 제품을 구매한 구매자들과의 거래 내역(구매 예약 포함)"이라고 이해하였습니다.\
> 그래서 제품 상제 정보 조회 시, 현재 사용자가 판매자인지 구매자인지를 파악하여 다른 조회 쿼리를 날리도록 하였습니다.

### 어려웠던 점
> 현재 주문 정보를 등록하는 서비스 로직은
> 1. 제품 상태가 판매중 상태(FOR_SALE)인지 검증
> 2. 구매자가 이미 주문했던 상품인지 검증
> 3. 주문 등록
> 4. 주문 등록이 완료되면, 제품의 수량이 감소하고, 수량이 0이 되면 예약중 상태(RESERVED) 상태가 되어 추가 주문이 불가능
> 
> 로 흘러갑니다.
> 
> 만약, 2명의 사용자가 주문을 하였을 때, 4번 로직이 실행되기 전에 제품 정보를 조회하면 둘 다 판매중 상태가 되어 문제없이 주문이 등록이 될 것이 우려가 됩니다.\
> 그래서 다수의 스레드가 동시에 주문 정보 로직을 실행했을 때, 문제가 없는지 테스트를 할 수 있는 코드를 작성하고자 하는데, 어떤 식으로 작성하는 것이 바람직한지 감이 잡히질 않습니다.


